# Software Development Plan

## Phase 0: Requirements Analysis (tag name `analyzed`)
*(20% of your effort)*

**Important - do not change the code in this phase**

Deliver:

*   [ ] Re-write the instructions in your own words.
    *   If you don't do this, you won't know what you're supposed to do!
    *   Don't leave out details!
*   [ ] Explain the problem this program aims to solve.
    *   Describe what a *good* solution looks like.
    *   List what you already know how to do.
    *   Point out any challenges that you can foresee.
*   [ ] List all of the data that is used by the program, making note of where it comes from.
    *   Explain what form the output will take.
*   [ ] List the algorithms that will be used (but don't write them yet).
*   [ ] Tag the last commit in this phase `analyzed`
    *   *Grace Points: if this tag is pushed by midnight on the Sunday before the due date, you will receive up to 5 points back*

## Instructions:

I need to refactor this program. I will start by deleting un-used code and import statements and bad comments. From there I will create new Modules to make the code more object oriented.
I will also rename bad variable names to make them more clear. I will also remove all magic numbers and assign them to well named variables that describe their purpose. I will also 
re-write some bad algorithms to make them more clear. I will also remove all non-constant global variables and create methods to get the values needed. 

## What this problem aims to solve.

The purpose of the code is to print out fractals that are based from equations. I need to make the code much more clear and I need to ensure that it is easier to change so I can add new 
features or make adjsutments to the code. 
The result should be a self documenting project that produces the same output.

A good solution would consist of splitting the code I have been given into new modules so they can be re-used and changed easisly.
I already know what the output will look like, I already know how to create modules

I do not know anything about tinker, this may pose as an issue later.

## Data used

User will tell the program which fractal they would like to see, It has data for max iterations, the julia constant, and other variables that are used for creating the image. They all 
need to be renamed to make them self documenting.

the output will be a tinker image of the fractal, it will also show values of i which is the number of iterations the pixel went through.


## algorithms used

One algorithm in the program is to iterate through each pixel to determine the color, another alortihm is used to paint the picture


## Phase 1: Design (tag name `designed`)
*(30% of your effort)*

**Important - do not change the code in this phase**

Deliver:

*   [ ] Function signatures that include:
    *   Descriptive names.
    *   Parameter lists.
    *   Documentation strings that explain its purpose and types of inputs and outputs.
*   [ ] Pseudocode that captures how each function works.
    *   Pseudocode != source code.  Do not paste your finished source code into this part of the plan.
*   Explain what happens in the face of good and bad input.
    *   Write a few specific examples that occur to you, and use them later when testing
*   [ ] Tag the last commit in this phase `designed`
    *   *Grace Points: if this tag is pushed by midnight on the Sunday before the due date, you will receive up to 5 points back*

## What each Module will be responsible for:

# main.py
   * driver/deals with command line arguments
   * imports modules to display fractal
# FractalInformation.py
   * Defines a dictionary that holds Mandelbrot and Phoenix configuration data
# Mandelbrot.py
   * defines a function that returns the iteration count of the MandelBrot Function
# Phoenix.py
   * defines a function that returns the iteration count of the Phoenix Function
# Palette.py
   * contains two color palettes, a palette is an array of colors
   * Gets the iteration count from Mandelbrot or Phoenix, the pixel is then colored P[count]
   * count can never be more than the len of P
   * Mandelbrot and Phoenix cannot import Palette
# ImagePainter.py
   * Creates the Tk window and a PhotoImage object
   * PhotoImage stores the pixels of the image
   * can create a PNG image file
   * imports tkinter

## Functions

# Mandelbrot Function:

def PixelIndx(c):
	max_iterations = 1000
	palLen = Palette.getlen()
	z = complex(0,0)
	for i in range (max_iterations)
		z = z*z + c
		if abs(z) >2
			if palLen is None:
				return i
			else:
				if i >= palLen
					i = palLen -1
				return i

# Phoenix Function:

def PixelIndx(z):
	c = complex(0.5667, 0)
	phoenix = complex (-.5,0)
	z_flipped = complex (z.imag, z.real)
	z_prev = 0+0j
	z = z_flipped
	for i in range(102):
		z_save = z
		z = z*z + c + (phoenix * z_prev)
		z_prev = z_save
		if abs(z)>2
			return i
	return 102

# Palette

def getlen():
   return len(Palette)

# ImagePainter

def paint(f,s)
min_c = centerX - axisLen /2, centerY - axisLen /2
max_c = centerX + axislen/2, centerY + axisLen/2
canvas = Canvas(win, width, hight, bg)
canvas.pack()
size = abs(max_c[0] - min_c[0])/2
for y in range(s)
	for x in range(s)
		c = complex(min_c[0] + x * size, min_c[1] + y * size)
		color = Palette.getColor(c)
		canvas.create_rectange(x,y, x+1, y+1, fill)

# main

def print fractals(fractals)
	for fractal in fractals:
		print(fractal)
if len(sys.argv) < 2:
	print("name for fractal as argument")
	all_fractals = Phoenix + mbrots
	print_fractals(all_fractals)
	sys.exit(1)
fractal_name = sys.argv[1]

if fractal name in Phoenix
	phoenix.PixelIndx(fractal_name)
elif fractal name in MbrotsL
	Mandelbrots.PixelIndx(fractal_name)
else:
	print("error: nor valid fractal name)
	print("choose on of the folowing)
	print(all_fractals)
	sys.exit(1)



### Plan for UML:

main is the driver, and it accesses FractalInformation and ImagePainter
ImagePainter accesses MandelBrot, Phoenix, and palette.

The main module gets the user input and directs it into the the imagePainter along with the fractal information
The ImagePainter uses the information passed into it from main module, it then will call functions from Phoenix or Mandelbrot to return the iteration count
It uses the iteration count to get the color at that index.

### Plan for Tests:

I will utilize the 6 tests given from the source code, They will need to be re-implemented to work with the changed code

I will create two new tests, one to ensure that the palettes are the expected len
and another to ensure that all colors in the palette are strings.


## Phase 2: Implementation (tag name `implemented`)
*(15% of your effort)*

**Finally, you can write code!**

Deliver:

*   [ ] More or less working code.
*   [ ] Note any relevant and interesting events that happened while you wrote the code.
    *   e.g. things you learned, things that didn't go according to plan
*   [ ] Tag the last commit in this phase `implemented`

I have run into a few issues with the implemenation,
I tried to run the mandelbrot function with the phoenix fractal
I also had issues with getColor where the iteration count was out of index,
I fixed this by checking if the iteration count is more than the len of the palette


## Phase 3: Testing and Debugging (tag name `tested`)
*(30% of your effort)*

Deliver:

*   [ ] A set of test cases that you have personally run on your computer.
    *   Include a description of what happened for each test case.
    *   For any bugs discovered, describe their cause and remedy.
    *   Write your test cases in plain language such that a non-coder could run them and replicate your experience.
*   [ ] Tag the last commit in this phase `tested`

I will test each of the fractals to ensure they didn't change.

all mandelbrots look correct,
the phoenix fractals don't seem to have as dark of colors.
This might be an issue in ImagePainter where I am getting the color.

all phoenix fractals now return their colors from the Grad palette, that fixed the color issue.

fractals have empty space on the left and bottom, it is a small empty space, but it hsould not be there
this might be caused by a wrong canvas size.
I fixed this by subtracting three from the canvas size.

Now I want to test bad inputs

bad input gave me an error instead of a usage message.
this was caused because I was assigning the fractal before I was checking if it existed

No parameters:
no parameters gave a usage message, but I wanted to indent the list, so I did

Capitalized fractal:
a capitalized fractal gives the correct error



## Phase 4: Deployment (tag name `deployed`)
*(5% of your effort)*

Deliver:

*   [ ] Tag the last commit in this phase `deployed`
*   [ ] Your repository is pushed to GitLab.
*   [ ] **Verify** that your final commit was received by browsing to its project page on GitLab.
    *   Ensure the project's URL is correct.
    *   Review the project to ensure that all required files are present and in correct locations.
    *   Check that unwanted files have not been included.
    *   Make any final touches to documentation, including the Sprint Signature and this Plan.
*   [ ] **Validate** that your submission is complete and correct by cloning it to a new location on your computer and re-running it.
	*	Run your program from the command line so you can see how it will behave when your grader runs it.  **Running it in PyCharm is not good enough!**
    *   Run through your test cases to avoid nasty surprises.
    *   Check that your documentation files are all present.


## Phase 5: Maintenance

Spend a few minutes writing thoughtful answers to these questions.  They are meant to make you think about the long-term consequences of choices you made in this project.

Deliver:

*   [ ] Write brief and honest answers to these questions:
    *   What parts of your program are sloppily written and hard to understand?
        *   Are there parts of your program which you aren't quite sure how/why they work?
        *   If a bug is reported in a few months, how long would it take you to find the cause?
    *   Will your documentation make sense to...
        *   ...anybody besides yourself?
        *   ...yourself in six month's time?
    *   How easy will it be to add a new feature to this program in a year?
    *   Will your program continue to work after upgrading...
        *   ...your computer's hardware?
        *   ...the operating system?
        *   ...to the next version of Python?
*   [ ] Make one final commit and push your **completed** Software Development Plan to GitLab.
*   [ ] Respond to the **Assignment Reflection Survey** on Canvas.


The ImagePainter is a bit long and hard to follow, It makes since to me becasue I wrote it to be how it is, but to someone else, it would be a bit confusing.
I understand what all parts of the code do, but it took awhile to get to that point.
A bug would take longer than I would like to be found.

My documentation will make since to other people and myself in six months.

it would be hard to add a new feature because the code is so dependent on its self that adding new things would just be a headache.

I think this program will work on different hardwear and diferent OSes. As long as they dont change TK

