# Software Development Plan

## Phase 0: Requirements Analysis (tag name `analyzed`)
*(20% of your effort)*

**Important - do not change the code in this phase**

Deliver:

*   [ ] Re-write the instructions in your own words.
    *   If you don't do this, you won't know what you're supposed to do!
    *   Don't leave out details!
*   [ ] Explain the problem this program aims to solve.
    *   Describe what a *good* solution looks like.
    *   List what you already know how to do.
    *   Point out any challenges that you can foresee.
*   [ ] List all of the data that is used by the program, making note of where it comes from.
    *   Explain what form the output will take.
*   [ ] List the algorithms that will be used (but don't write them yet).
*   [ ] Tag the last commit in this phase `analyzed`
    *   *Grace Points: if this tag is pushed by midnight on the Sunday before the due date, you will receive up to 5 points back*

## instructions:

* Create 8 unit tests for the project, these should fail at the beginning but pass as the project gets closer to passing.
  * some tests could be about handleing errors, others should be about how data is processed
* Define a Fractle abstract class that holds the function of count(), this should raise an error because it needs to be overloaded.
  * Count will take a complex number as the input, and it will return the number of iterations, or the max.
* Create new fractle classes, need four, convert Phoenix and Mandelbrot to these for two, raise equation from phoenix to a higer power for another,
The last one will need to be a new equation entierly.
* Create a FractleFactory, this is a class or module that will contain a function to return a fractle object beased on the input supplied by the user.
  * When No fractle is given, it will return the default fractle
  * checks for errors, unrecognized fractles, and errors with the fractle config data.
* Create the Fractle Parser, this is a class or module that will read the .fractle argument from the command line and converts it to data that the program can use
  * read one line at a time
  * convert all text to be lowercase
  * Split lines into Key and data, these will be seperated by :
  * Verify that all info given is in the correct format.
  * convert all strings to numbers
  * all white space is ignored
  * all comments are ignored
  * raises errors if config data does not follow correct format,
  * raises errors for wrong data types, or blank data
* Define abstract palette class and at least two subclasses
  * Palette will have a placeholder getColor() that will return an error when called
  * palettes can have between 64 - 512 iterations
* Create the palette factory, class or module
  * returns a palette specified by the user
  * returns default if no specifications are given.
  * if specification does not exist, raise an error
* ImagePainter, Class, takes fractleFactory, PaletteFactory, and fractleParser as input
  * this class will call the .count() methods
  * rely on duck typing
* User Interface, User will know how to get into the command line, they will run the program with optional parameters of fractle name and palette
  * if no arguments are given, default fractle will print.
  * raises errors for misspelled files
  * raises error if file doesn't follow format
* Default Fractle is hardcoded into the dictionary already
  * between 256 and 640 pixels in size
  * max iter between 64 and 256
* Update UML and User's manual to reflect new changes to project.

## What this program aims to solve

* this project will allow a user to print various fractles of different colors to their screen. when no fractles or color palettes are given
a default image is printed
* Images are created using data from the fractle configuration data, this data is used in math formulas to return the iteration count of the formula
this count will corispond to a color in the palette
* Images will save to the users computer when complete.
* program will give user the runtime of the program

# what makes a good solution

* program should not crash unexpectedly, catches all errors before image starts printing
* Should print colorful fractle of the users choosing, or a default fractle
* Has multiple equations to get the iteration count.

# what I know how to do

* catch errors
* convert modules into classes
* create a default fractle to be printed
* process files and split them to get correct data
* convert str to float
* convert text to lowercase

# What I need to learn

* how to use inheritance, we are learning this in class but I have not done it myself, so I only know the concept of this
* I don't know how to use the colour.Color, but we learned about it in class!

# data

* this program will accept user input for which fractal and which color palette
* Most data is found in the fractal config file
* This data gives the center of the fractal, the len, the type, the number of pixels
* The program will output a TK image of the fractal,
* It will also give them a progress bar while it is printing
* It will save the image to their computer and tell them what the file is called

# Algorithms

* I will need two new algorithms for the iteration counts, 
* I will use an algorithm for different color palettes
* I will need an algorithm to check user inputs and make sure it is correct
* I will need an algorithm to check all of the fractal config data to ensure it is usable


## Phase 1: Design (tag name `designed`)
*(30% of your effort)*

**Important - do not change the code in this phase**

Deliver:

*   [ ] Function signatures that include:
    *   Descriptive names.
    *   Parameter lists.
    *   Documentation strings that explain its purpose and types of inputs and outputs.
*   [ ] Pseudocode that captures how each function works.
    *   Pseudocode != source code.  Do not paste your finished source code into this part of the plan.
*   Explain what happens in the face of good and bad input.
    *   Write a few specific examples that occur to you, and use them later when testing
*   [ ] Tag the last commit in this phase `designed`
    *   *Grace Points: if this tag is pushed by midnight on the Sunday before the due date, you will receive up to 5 points back*


## Phase 2: Implementation (tag name `implemented`)
*(15% of your effort)*

**Finally, you can write code!**

Deliver:

*   [ ] More or less working code.
*   [ ] Note any relevant and interesting events that happened while you wrote the code.
    *   e.g. things you learned, things that didn't go according to plan
*   [ ] Tag the last commit in this phase `implemented`


## Phase 3: Testing and Debugging (tag name `tested`)
*(30% of your effort)*

Deliver:

*   [ ] A set of test cases that you have personally run on your computer.
    *   Include a description of what happened for each test case.
    *   For any bugs discovered, describe their cause and remedy.
    *   Write your test cases in plain language such that a non-coder could run them and replicate your experience.
*   [ ] Tag the last commit in this phase `tested`


## Phase 4: Deployment (tag name `deployed`)
*(5% of your effort)*

Deliver:

*   [ ] Tag the last commit in this phase `deployed`
*   [ ] Your repository is pushed to GitLab.
*   [ ] **Verify** that your final commit was received by browsing to its project page on GitLab.
    *   Ensure the project's URL is correct.
    *   Review the project to ensure that all required files are present and in correct locations.
    *   Check that unwanted files have not been included.
    *   Make any final touches to documentation, including the Sprint Signature and this Plan.
*   [ ] **Validate** that your submission is complete and correct by cloning it to a new location on your computer and re-running it.
	*	Run your program from the command line so you can see how it will behave when your grader runs it.  **Running it in PyCharm is not good enough!**
    *   Run through your test cases to avoid nasty surprises.
    *   Check that your documentation files are all present.


## Phase 5: Maintenance

Spend a few minutes writing thoughtful answers to these questions.  They are meant to make you think about the long-term consequences of choices you made in this project.

Deliver:

*   [ ] Write brief and honest answers to these questions:
    *   What parts of your program are sloppily written and hard to understand?
        *   Are there parts of your program which you aren't quite sure how/why they work?
        *   If a bug is reported in a few months, how long would it take you to find the cause?
    *   Will your documentation make sense to...
        *   ...anybody besides yourself?
        *   ...yourself in six month's time?
    *   How easy will it be to add a new feature to this program in a year?
    *   Will your program continue to work after upgrading...
        *   ...your computer's hardware?
        *   ...the operating system?
        *   ...to the next version of Python?
*   [ ] Make one final commit and push your **completed** Software Development Plan to GitLab.
*   [ ] Respond to the **Assignment Reflection Survey** on Canvas.
